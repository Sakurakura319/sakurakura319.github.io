
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HEllO || </title>
    <meta name="author" content="saku">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">HEllO</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/like/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/like/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://en.korilin.com">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>HEllO</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/like/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/like/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a target="_blank" rel="noopener" href="https://en.korilin.com">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1> </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/3/29
        </span>

        

        
    </div>

    <div class="content" v-pre>
        <h1 id="Vue3——Diff算法"><a href="#Vue3——Diff算法" class="headerlink" title="Vue3——Diff算法"></a>Vue3——Diff算法</h1><h4 id="diff的原理。"><a href="#diff的原理。" class="headerlink" title="diff的原理。"></a>diff的原理。</h4><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>在真正进入Diff之前，快速Diff会先执行一段”预处理“的前置操作。目的是先把可以直接排除的项去掉，降低diff的操作量。这个思路来自与unix等操作系统的文件内容diff，举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const TEXT1 = &#x27;I am a front-end developer&#x27;</span><br><span class="line">const TEXT2 = &#x27;I am a back-end developer&#x27; </span><br></pre></td></tr></table></figure>



<p>要对这两段文本进行diff，首先会对它进行全等比较：if (TEXT1 === TEXT2) return，如果全等旧没有必要进入核心的diff步骤了。除了全等比较，还会对他们进行前缀于后缀的比较。一眼就能看到这两段文本的头部和尾部分别有一段相同的内容。</p>
<p>I am a front -end developer</p>
<p>I am a back -end developer</p>
<p>对于相同的内容，不需要进行Diff操作，因此对于 TEXT1 和 TEXT2 来说，真正需要Diff操作的部分是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TEXT1</span>：front</span><br><span class="line"><span class="title class_">TEXT2</span>：back </span><br></pre></td></tr></table></figure>

<p> 这是一种简化问题的方式，好处是可以在特定情况下能够轻松判断文本的插入和删除。 </p>
<p> 预处理便是将上面的例子掐头去尾的过程，那么再看另外一个例子： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TEXT3</span> =  you</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TEXT4</span> =  you too </span><br></pre></td></tr></table></figure>

<p> 这两段文本经过预处理之后可以得到： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TEXT3</span>：</span><br><span class="line"><span class="title class_">TEXT4</span>：too </span><br></pre></td></tr></table></figure>

<p> 如果 TEXT3 是新的内容，那么只需要删除多余的 too 就可以完成文本更新；否则，添加 too 完成文本更新。 </p>
<h5 id="预处理要怎么做-例一"><a href="#预处理要怎么做-例一" class="headerlink" title="预处理要怎么做 - 例一"></a>预处理要怎么做 - 例一</h5><p> 快速Diff算法就是借鉴了纯文本的diff算法中预处理的步骤。以下面的两组节点为例： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldChildren = [&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;2&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> newChildren = [&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;4&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;2&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span> &#125;</span><br><span class="line">] </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678968895086.png" alt="1678968895086"></p>
<p> 从图中可以看到，两组节点具有相同的前置节点 p - 1，以及相同的后置节点 p - 2、p - 3。对于相同的前置节点和后置节点，由于它们在新旧两组子节点中的相对位置不变，所以不需要移动它们，但仍然要在它们之间打补丁。 </p>
<p>处理前置节点</p>
<p> 对于前置节点，可以建立索引 j ，初始值为0，指向两组子节点的开头。开启一个while循环，让索引 j 递增，直至遇到不同的节点为止。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="keyword">const</span> newChildren = n1.<span class="property">childrenconst</span> oldChildren = n2.<span class="property">children</span><span class="comment">// 处理相同的前置节点// 索引 j 指向新旧两组子节点的开头let j = 0let oldVNode = oldChildren[j]let newVNode = newChildren[j]// while 循环向后遍历，直到遇到不同 key 值的节点为止while (oldVNode.key === newVNode.key) &#123;// 调用 patch 函数进行更新patch(oldVNode, newVNode, container)// 让索引 j 递增以对下一个节点进行处理j++oldVNode = oldChildren[j]newVNode = newChildren[j]&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p> 上面使用while循环查找所有相同的前置节点，并调用patch函数进行打补丁，直到遇到key值不同的节点为止。这样就完成了对前置节点的预处理。 </p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678968949087.png" alt="1678968949087"></p>
<h5 id="处理后置节点"><a href="#处理后置节点" class="headerlink" title="处理后置节点"></a>处理后置节点</h5><p> 接下来就要处理后置节点，因为新旧两组子节点的数量不同所以还需要两个索引，指向新旧两组子节点的最后一个节点。然后再开启一个while循环从后向前遍历这两组子节点，直到遇到key值不同的节点为止。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="keyword">const</span> newChildren = n1.<span class="property">childrenconst</span> oldChildren = n2.<span class="property">children</span><span class="comment">// 处理相同的前置节点// 索引 j 指向新旧两组子节点的开头let j = 0let oldVNode = oldChildren[j]let newVNode = newChildren[j]// while 循环向后遍历，直到遇到不同 key 值的节点为止while (oldVNode.key === newVNode.key) &#123;// 调用 patch 函数进行更新patch(oldVNode, newVNode, container)// 让索引 j 递增以对下一个节点进行处理j++oldVNode = oldChildren[j]newVNode = newChildren[j]&#125;// 获取最后的子节点的索引值let oldEnd = oldChildren.length - 1let newEnd = newChildren.length - 1// 获取最后的子节点oldVNode = oldChildren[oldEnd]newVNode = newChildren[newEnd]// while 循环从后向前遍历，直至遇到不同 key 值得节点为止while (oldVNode.key === newVNode.key) &#123;// 调用 patch 函数进行更新patch(oldVNode, newVNode, container)// 让索引 j 递减以对下一个节点进行处理（因为是从后往前所以递减）oldEnd--newEnd--oldVNode = oldChildren[oldEnd]newVNode = newChildren[newEnd]&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p> 与处理相同得前置节点一样，在while循环内，需要调用patch函数进行打补丁，然后递减两个索引oldEnd、newEnd。 </p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678968980160.png" alt="1678968980160"></p>
<h5 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h5><p>从图中可以看到，相同的前置节点和后置节点被处理完之后，旧的一组一节点全部被处理了，而在新的一组子节点中，还有一个没有被处理的节点 p - 4。因此得出，p - 4 是一个新增节点：</p>
<p>oldEnd &lt; j 成立，说明在预处理时，所有旧子节点都处理完毕了</p>
<p>newEnd &gt;= j成立，说明预处理后，新的一组子节点中，存在未被处理的节点，这些节点就是新增的节点</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969028166.png" alt="1678969028166"></p>
<p> 索引值在 j 和 newEnd 之间的任何节点都需要作为新的子节点进行挂载，挂载新元素就要找到正确的锚点元素。从上图中看到，新增节点应该挂载到节点 p - 2 所对应的真实DOM前面，所以将 p - 2 作为挂载操作的锚点元素。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="comment">// 省略部分代码// 预处理完毕后，如果满足 j --&gt; newEnd 之间的节点应该作为新节点插入if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;// 锚点的索引const anchorIndex = newEnd + 1// 得到锚点元素const anchor = anchorIndex &lt; newChildren.length ? newChildren[anchorIndex].el : null// 将新增的节点逐个挂载while (j &lt;= newEnd) &#123;patch(null, newChildren[j++], container, anchor)&#125;&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="删除节点-例二"><a href="#删除节点-例二" class="headerlink" title="删除节点 - 例二"></a>删除节点 - 例二</h5><p>看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldChildren = [&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span> &#125;]<span class="keyword">const</span> newChildren = [&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;2&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span> &#125;] </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969063661.png" alt="1678969063661"></p>
<p> 该例进行预处理后的结果为： </p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969077671.png" alt="1678969077671"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="comment">// 省略部分代码// 预处理完毕后，如果满足 j --&gt; newEnd 之间的节点应该作为新节点插入if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;// 锚点的索引const anchorIndex = newEnd + 1// 得到锚点元素const anchor = anchorIndex &lt; newChildren.length ? newChildren[anchorIndex].el : null// 将新增的节点逐个挂载while (j &lt;= newEnd) &#123;patch(null, newChildren[j++], container, anchor)&#125;&#125; else if (j &gt; newEnd &amp;&amp; j&lt;= oldEnd) &#123;// 有要删除的节点while (j &lt;= oldEnd) &#123;unmount(oldChildren[j++])&#125;&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="是否需要进行移动操作-例三"><a href="#是否需要进行移动操作-例三" class="headerlink" title="是否需要进行移动操作 - 例三"></a>是否需要进行移动操作 - 例三</h4><p>上面的例子是比较简单的操作，处理预处理，只有挂载和卸载操作。但有时情况会很复杂。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldChildren = [&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;4&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;2&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;7&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;5&#x27;</span> &#125;]<span class="keyword">const</span> newChildren = [&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;1&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;2&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;4&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;6&#x27;</span> &#125;,&#123; <span class="attr">type</span>: <span class="string">&#x27;p&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;5&#x27;</span> &#125;] </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969101230.png" alt="1678969101230"></p>
<p>该例经过预处理后，新的和旧的两组子节点都有部分节点未处理。这个时候就需要进一步操作，看之前的简单Diff和双端Diff可以了解到，它们都遵守同样的处理规则：</p>
<ul>
<li><p>判断是否有节点需要移动，以及如何移动* 找出那些需要被添加或移除的节点</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969119638.png" alt="1678969119638"></p>
<p>快速Diff算法也不例外，接下来的要做的就是判断哪些节点需要移动以及应该如何移动。</p>
<p>从图中可以看到新增j &gt; oldEnd &amp;&amp; j &lt;= newEnd和删除j &gt; newEnd &amp;&amp; j&lt;= oldEnd的条件不满足任何一个，所以增加else分支来处理非理想情况。接下来的内容有一丢丢复杂了哦</p>
<p>构造source<br>首先需要构造一个数组 source，它的长度等于新的一组子节点在经过预处理之后剩余未处理节点的数量，并且source中每个元素的初始值都是-1。<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969131378.png" alt="1678969131378"></p>
</li>
</ul>
<p> 通过上图可以看到，source 数组将用来存储新的一组子节点中的节点在旧的一组子节点中的位置索引，后面将会使用它计算出一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97&spm=1001.2101.3001.7020">最长递增子序列</a>，用于辅助完成DOM移动的操作。 <img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969145775.png" alt="1678969145775"></p>
<p>source数组构造完成，接下来看看如何填充source数组：</p>
<p>新的一组节点中的第一个节点 p - 3 在旧的一组子节点中的索引为2，因此source数组的第一个元素值为2* 新的一组节点中的第二个节点 p - 4 在旧的一组子节点中的索引为3，因此source数组的第二个元素值为3* 新的一组节点中的第三个节点 p - 2 在旧的一组子节点中的索引为1，因此source数组的第三个元素值为1* 新的一组节点中的第四个节点 p - 7 在旧的一组子节点中找不到与之key值相等的节点，所以source数组的第四个元素值仍然为 -1###### 这里提出一个问题，为什么查找时新的一组节点去掉收尾，旧的找的却是全部？<br>完成source数组的填充</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="comment">// 省略部分代码if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;// 省略&#125; else if (j &gt; newEnd &amp;&amp; j&lt;= oldEnd) &#123;// 省略&#125; else &#123;// j 指向的是未处理的新节点的开头// newEnd 指向的是未处理的新节点的末尾// 所以 newEnd - j + 1就是剩余未处理的新节点const count = newEnd - j + 1// 构造一个与未处理的新节点数量相等长度的数组，并用 -1 填充const source = new Array(count)source.fill(-1)// 遍历旧的一组子节点for (let i = oldStart; i &lt;= oldEnd; i++) &#123;// 获取本次循环用来对比的旧节点const oldVNode = oldChildren[i]// 遍历新的一组子节点for (let k = newStart; k &lt;= newEnd; k++) &#123;// 获取本次循环用来对比的新节点const newVNode = newChildren[i]// 找到具有相同 key 值得可复用节点if (oldVNode.key === newVNode.key) &#123;// 调用patch进行更新patch(oldVNode, newVNode, container)// 最后填充 source 数组source[k - newStart] = i&#125;&#125;&#125;&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>两层for循环我觉得有必要说一下：</p>
<p><em>上面的两层循环如果可以看懂不需要看这一段，有点啰嗦，防止误导，没看懂的话再结合图看下面内容更直观一些</em></p>
<ul>
<li>外层循环的条件：<code>let i = oldStart; i &lt;= oldEnd; i++</code></li>
</ul>
<blockquote>
<p>i = oldStart 表示外层循环从旧节点列表被预处理之后，剩余节点中的第一个节点开始，oldChildren[i] 等于 oldChildren[oldStart] 等同于 旧节点列表剩余节点的第一个元素</p>
<p>i &lt;= oldEnd 表示外层循环从旧节点列表被预处理之后，剩余节点中的最后一个节点结束，最后 i 会递增到等于oldEnd，所以有oldChildren[i] 等于 oldChildren[oldEnd] 等同于 旧节点列表剩余节点的最后一个元素</p>
</blockquote>
<ul>
<li>内层循环的条件：<code>let k = newStart; k &lt;= newEnd; k++</code></li>
</ul>
<blockquote>
<p> 与外层循环同理 </p>
</blockquote>
<ul>
<li>填充操作：<code>source[k - newStart] = i</code></li>
</ul>
<blockquote>
<p>i 指的是当前外层循环中的旧节点对应的索引，因此填充source的时候用 i 作为值</p>
<p>k 指的是当前内层循环中的新节点对应的索引，初始值未newStart</p>
<p>当前的 newEnd 指的是在所有新节点中，最后一个未被处理的节点的索引</p>
<p>newStart指的是在所有新节点中，第一个未被处理的节点的索引</p>
<p>而 k 的最大值是newEnd，newEnd - newStart就是source最后一个元素的索引</p>
<p>k 的最小值是 newStart，newStart - newStart就是source第一个元素的索引</p>
<p>因此用 k - newStart 作为填充source时的索引</p>
</blockquote>
<h5 id="构造索引表"><a href="#构造索引表" class="headerlink" title="构造索引表"></a>构造索引表</h5><p>索引表的目的更多是为了优化上一步的操作，因为两层for循环，时间复杂度未 O(n1 * n2)，当新旧两组子节点多的时候可能会带来性能问题。因此构造一个索引表，用来存储 节点的key 和 节点位置索引 之间的映射。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">key1</span>: index1,<span class="attr">key2</span>: index2</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p> 索引表的结构是这样，key表示一个vNode的key，这个key的值（index），就是这个key对应的vNode在就节点列表中的索引。 </p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969265517.png" alt="1678969265517"></p>
<p>索引表构造完成之后，拿旧节点的 key 取索引表中查找该节点在新的一组子节点中的位置，找到了对它进行打补丁操作并且记录到source中。</p>
<p>构造索引表的实现（实际上只是优化了构造source的操作）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="comment">// 省略部分代码if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;// 省略&#125; else if (j &gt; newEnd &amp;&amp; j&lt;= oldEnd) &#123;// 省略&#125; else &#123;// j 指向的是未处理的新节点的开头// newEnd 指向的是未处理的新节点的末尾// 所以 newEnd - j + 1就是剩余未处理的新节点const count = newEnd - j + 1// 构造一个与未处理的新节点数量相等长度的数组，并用 -1 填充const source = new Array(count)source.fill(-1)// oldStart newStart 都指向未处理的新节点列表的起始索引const oldStart = jconst newStart = j// 构造索引表const keyIndex = &#123;&#125;// 循环新节点列表经预处理后剩余的节点for (let i = newStart; i &lt;= newEnd; i++) &#123;// newChildren[i].key 指的是当前循环的的节点的key属性keyIndex[newChildren[i].key] = i&#125;// 循环旧的一组节点中剩余未处理的节点for (let i = oldStart; i &lt;= oldEnd; i++) &#123;// 取到当前的旧节点oldVNode = oldChildren[i]// 通过索引表快速找到新的一组子节点中具有 相同key值 的节点位置const k = keyIndex[oldVNode.key]if (typeof k !== &#x27;undefined&#x27;) &#123;newVNode = newChildren[k]// 调用 patch 完成更新patch(oldVNode, newVNode, container)// 填充source数组source[k - newStart] = i&#125; else &#123;// 如果没有找到对应索引，说明新节点列表没有该节点，需要卸载unmount(oldVNode)&#125;&#125;&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>到这里初始化source数组的相关操作已经结束，接下来就应该判断节点是否需要移动（快速Diff算法与简单Diff算法判断是否需要移动的方法很相似）。</p>
<p>根据上面的计算已经可以得出，source的结果是 [2, 3, 1, -1]</p>
<p>是否需要移动<br>定义一个变量 moved 代表当前节点是否需要移动，pos 代表遍历就得子节点得过程中遇到得最大索引值。如果在遍历过程中遇到得索引值呈现递增趋势，则说明不需要移动；否则需要移动。 不明白的话建议看看简单Diff算法（了解以下就能明白了哦）。</p>
<p>简单diff算法 - 传送门</p>
<p>改动较少，添加注释的代码是新增代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="comment">// 省略部分代码if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;// 省略&#125; else if (j &gt; newEnd &amp;&amp; j&lt;= oldEnd) &#123;// 省略&#125; else &#123;const count = newEnd - j + 1const source = new Array(count)source.fill(-1)const oldStart = jconst newStart = j// 新增两个变量let moved = false // 是否需要移动let pos = 0 // 遍历一组子节点的过程中遇到的最大索引值const keyIndex = &#123;&#125;for (let i = newStart; i &lt;= newEnd; i++) &#123;keyIndex[newChildren[i].key] = i&#125;for (let i = oldStart; i &lt;= oldEnd; i++) &#123;oldVNode = oldChildren[i]const k = keyIndex[oldVNode.key]if (typeof k !== &#x27;undefined&#x27;) &#123;newVNode = newChildren[k]patch(oldVNode, newVNode, container)source[k - newStart] = i// 判断节点是否需要移动if (k &lt; pos) &#123;// pos 代表遍历就得子节点得过程中遇到得最大索引值moved = true&#125; else &#123;// 如果出现大于当前pos的值，则更新pospos = k&#125;&#125; else &#123;unmount(oldVNode)&#125;&#125;&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="卸载多余节点"><a href="#卸载多余节点" class="headerlink" title="卸载多余节点"></a>卸载多余节点</h5><p>添加一个数量表示 patched，表示已经更新过的节点数量。已经更新过的节点数量应该小于等于新的一组子节点中需要更新的节点数量，如果它超过了新的一组子节点中需要更新的节点数量，则说明有多余的节点，应该将它卸载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span> (n1, n2, container) &#123;<span class="comment">// 省略部分代码if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;// 省略&#125; else if (j &gt; newEnd &amp;&amp; j&lt;= oldEnd) &#123;// 省略&#125; else &#123;const count = newEnd - j + 1const source = new Array(count)source.fill(-1)const oldStart = jconst newStart = jlet moved = falselet pos = 0const keyIndex = &#123;&#125;for (let i = newStart; i &lt;= newEnd; i++) &#123;keyIndex[newChildren[i].key] = i&#125;// 新增变量 patched，待变更新过的节点数量let patched = 0for (let i = oldStart; i &lt;= oldEnd; i++) &#123;oldVNode = oldChildren[i]// 如果更新过的节点数量小于等于需要更新的节点数量。则执行更新if (patched &lt;= count) &#123;const k = keyIndex[oldVNode.key]if (typeof k !== &#x27;undefined&#x27;) &#123;newVNode = newChildren[k]patch(oldVNode, newVNode, container)// 更新一个节点之后就让它递增patched++source[k - newStart] = iif (k &lt; pos) &#123;moved = true&#125; else &#123;pos = k&#125;&#125; else &#123;unmount(oldVNode)&#125;&#125; else &#123;// 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点unmount(oldVNode)&#125;&#125;&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p> 到这里已经可以通过moved的值，知道了是否需要移动当前循环中的节点。 </p>
<p>如何移动元素<br>还是继续使用上面的例子（例三）</p>
<p>目前为止已经能知道 在遍历预处理之后的节点列表时，哪些节点是需要移动的；并且构造出了source数组，其值为[2, 3, 1, -1]。这些都是为接下来的移动元素操作做铺垫。</p>
<p>最长递增子序列用来得出不需要移动的节点片段</p>
<p>首先要根据source计算出它的最长递增子序列seq（本片主要讲Diff算法，不过多解释：最长递增子序列 - 传送门）</p>
<p>求得的source中，它的最长递增子序列为 [0, 1]</p>
<blockquote>
<p> 解释以下为什么：数组 [2, 3, 1, -1] 中，从开始到结尾递增的元素是 <code>2, 3</code>这部分，它们对应的下标是 <code>0, 1</code>，所以说它们的最长递增子序列为 [0, 1]，这里说的是最长递增子序列对应的下标，并不是具体的值。 </p>
</blockquote>
<p> 现在已经有了最长递增子序列的信息，为了让子序列与新的索引值产生对应关系，接下来要对节点进行编号。要怎样进行编号呢？</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678969336991.png" alt="1678969336991"></p>
<p>新的一组子节点中，重新编号后索引值为 0 和 1 的两个节点在更新前后顺序没有任何变化。即重新编号后，索引值为 0 和 1 的节点不需要移动。在新的一组子节点中，节点 p - 3 的索引为0，节点 p - 4 的索引为1，所以节点 p - 3 和 p - 4 所对应的真实DOM不需要移动。</p>
<h4 id="Vue-3中的预处理"><a href="#Vue-3中的预处理" class="headerlink" title="Vue 3中的预处理"></a>Vue 3中的预处理</h4><p>了解完上述的理论背景之后，我们来看一下在Vue 3中是怎么实现的。假设现在有下图的两组新旧节点组：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678965500678.png" alt="1678965500678"></p>
<p>按照快速diff的预处理，我们会先扫描两组的前后内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">  <span class="comment">// 拿到两组Children节点组</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = n2.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span></span><br><span class="line">  <span class="comment">// 用j定义头索引</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldVNode = oldChildren[j]</span><br><span class="line">  <span class="keyword">let</span> newVNode = newChildren[j]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始扫描头部</span></span><br><span class="line">  <span class="comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line">  <span class="keyword">while</span> (oldVNode.<span class="property">key</span> === newVNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">    j++</span><br><span class="line">    oldVNode = oldChildren[j]</span><br><span class="line">    newVNode = newChildren[j]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始处理尾部</span></span><br><span class="line">  <span class="comment">// 由于尾部跟头部不同，它们可能不一样。因此需要定义各自的索引</span></span><br><span class="line">  <span class="keyword">let</span> oldEnd = oldChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newEnd = newChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  oldVNode = oldChildren[oldEnd]</span><br><span class="line">  newVNode = newChildren[newEnd]</span><br><span class="line">  <span class="comment">// 开始扫描尾部</span></span><br><span class="line">  <span class="comment">// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line">  <span class="keyword">while</span> (oldVNode.<span class="property">key</span> === newVNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">    oldEnd--</span><br><span class="line">    newEnd--</span><br><span class="line">    oldVNode = oldChildren[oldEnd]</span><br><span class="line">    newVNode = newChildren[newEnd]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把代码相关的描述写在注释中，大家可以看到现在我们通过j，oldEnd和newEnd作为索引，和两个while循环实现了两组节点组的头尾处理。处理完之后节点应该是这样的：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678965543454.png" alt="1678965543454"></p>
<p>增删节点<br>根据这个思路，如果两个内容是一致的，在预处理阶段就能处理完了。但很多时候并不会那么顺利，如我们上面的例子中，新节点组中的Node5 就是一个新的节点，需要我们有一个插入新节点操作。同样，如果是旧节点组中有额外的节点，则需要一个删除旧节点的操作。</p>
<p>新增节点<br>那么，我们首先要知道什么条件下才应该插入节点。根据上图我们可以得出，当j大于oldEnd且小于等于newEnd，就应该新增节点。由此我们得出代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 满足两者则需要新增节点    </span></span><br><span class="line"><span class="keyword">if</span> (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;</span><br><span class="line">      <span class="comment">// 锚点的索引</span></span><br><span class="line">      <span class="keyword">const</span> anchorIndex = newEnd + <span class="number">1</span></span><br><span class="line">      <span class="comment">// 锚点元素</span></span><br><span class="line">      <span class="keyword">const</span> anchor = anchorIndex &lt; newChildren.<span class="property">length</span> ? newChildren[anchorIndex].<span class="property">el</span> : <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 采用 while 循环，调用 patch 函数逐个挂载新增的节点</span></span><br><span class="line">      <span class="keyword">while</span> (j &lt;= newEnd) &#123;</span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, newChildren[j++], container, anchor)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的patch实际上是mountElement，在patch源码中有以下处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">n1, n2, container, anchor</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      <span class="title function_">mountElement</span>(n2, container, anchor)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">patchElement</span>(n1, n2)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>删除节点<br>同理可得，当j大于newEnd且 j 小于等于 oldEnd时，则需要删除节点。可以对照下图：</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678965575932.png" alt="1678965575932"></p>
<p>得出代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;</span><br><span class="line">  <span class="comment">// 省略新增节点的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; newEnd &amp;&amp; j &lt;= oldEnd) &#123;</span><br><span class="line">  <span class="comment">// j -&gt; oldEnd 之间的节点应该被卸载</span></span><br><span class="line">  <span class="keyword">while</span> (j &lt;= oldEnd) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(oldChildren[j++])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="diff处理"><a href="#diff处理" class="headerlink" title="diff处理"></a>diff处理</h4><p>然而，在实际开发中往往存在着更为复杂的情况。如下图，新旧两组的节点长度是一致的，但各不相同。</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678965607858.png" alt="1678965607858"></p>
<p>针对这种情况，如果是暴力地把3行替换显然不是最好的做法。我们最直观的感受是希望可以把Node 2和Node 3 放到对的位置，然后把Node4 替换Node 1。</p>
<p>快速Diff中使用了一个source数组来记录新节的位置索引，并用-1来代表需要新增的节点，整体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 新的一组子节点中剩余未处理节点的数量</span></span><br><span class="line"><span class="keyword">const</span> count = newEnd - j + <span class="number">1</span>  </span><br><span class="line"> <span class="comment">// 构造 source 数组，并默认填充-1</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> <span class="title class_">Array</span>(count)</span><br><span class="line">source.<span class="title function_">fill</span>(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引从预处理后的j开始</span></span><br><span class="line"><span class="keyword">const</span> oldStart = j</span><br><span class="line"><span class="keyword">const</span> newStart = j</span><br><span class="line"><span class="comment">// moved用作标识是否需要重新排序</span></span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line"><span class="comment">// pos记录上一个找到的节点的位置，用于辅助设置moved</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line"><span class="comment">// keyIndx是一个缓存表，记录新节点的key和索引的关系</span></span><br><span class="line"><span class="keyword">const</span> keyIndex = &#123;&#125;</span><br><span class="line"><span class="comment">// 先把新节点全部放keyIndx</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = newStart; i &lt;= newEnd; i++) &#123;</span><br><span class="line">  keyIndex[newChildren[i].<span class="property">key</span>] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录从旧节点中找到匹对的次数</span></span><br><span class="line"><span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = oldStart; i &lt;= oldEnd; i++) &#123;</span><br><span class="line">  oldVNode = oldChildren[i]</span><br><span class="line">  <span class="keyword">if</span> (patched &lt; count) &#123;</span><br><span class="line">    <span class="comment">// k是从keyIndex中找到的节点在新节点组中的索引</span></span><br><span class="line">    <span class="keyword">const</span> k = keyIndex[oldVNode.<span class="property">key</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> k !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      newVNode = newChildren[k]</span><br><span class="line">      <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">      patched++</span><br><span class="line">      <span class="comment">// 修改对应source中的项</span></span><br><span class="line">      source[k - newStart] = i</span><br><span class="line">      <span class="comment">// 判断是否需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (k &lt; pos) &#123;</span><br><span class="line">        moved = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = k</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没找到</span></span><br><span class="line">      <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点中的内容已经全都匹对过了，说明剩下的全是应该删除的</span></span><br><span class="line">    <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在遍历完旧节点之后，情况大致如下： </p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1678965666413.png" alt="1678965666413"></p>
<p>我们就可以根据moved判断出是否需要重选排序。排序的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (moved) &#123;</span><br><span class="line">  <span class="comment">// lis是一个排序函数把source变成一个递增数组。</span></span><br><span class="line">  <span class="keyword">const</span> seq = <span class="title function_">lis</span>(source)</span><br><span class="line">  <span class="comment">// s 指向最长递增子序列的最后一个值</span></span><br><span class="line">  <span class="keyword">let</span> s = seq.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> i = count - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source[i] === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明索引为 i 的节点是全新的节点，应该将其挂载</span></span><br><span class="line">      <span class="comment">// 该节点在新 children 中的真实位置索引</span></span><br><span class="line">      <span class="keyword">const</span> pos = i + newStart</span><br><span class="line">      <span class="keyword">const</span> newVNode = newChildren[pos]</span><br><span class="line">      <span class="comment">// 该节点下一个节点的位置索引</span></span><br><span class="line">      <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">      <span class="comment">// 锚点</span></span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; newChildren.<span class="property">length</span></span><br><span class="line">        ? newChildren[nextPos].<span class="property">el</span></span><br><span class="line">        : <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 挂载</span></span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, newVNode, container, anchor)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i !== seq[j]) &#123;</span><br><span class="line">      <span class="comment">// 说明该节点需要移动</span></span><br><span class="line">      <span class="comment">// 该节点在新的一组子节点中的真实位置索引</span></span><br><span class="line">      <span class="keyword">const</span> pos = i + newStart</span><br><span class="line">      <span class="keyword">const</span> newVNode = newChildren[pos]</span><br><span class="line">      <span class="comment">// 该节点下一个节点的位置索引</span></span><br><span class="line">      <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">      <span class="comment">// 锚点</span></span><br><span class="line">      <span class="keyword">const</span> anchor = nextPos &lt; newChildren.<span class="property">length</span></span><br><span class="line">        ? newChildren[nextPos].<span class="property">el</span></span><br><span class="line">        : <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 移动</span></span><br><span class="line">      <span class="title function_">insert</span>(newVNode.<span class="property">el</span>, container, anchor)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当 i === seq[j] 时，说明该位置的节点不需要移动</span></span><br><span class="line">      <span class="comment">// 并让 s 指向下一个位置</span></span><br><span class="line">      s--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体代码<br>删除注释，整体贴一遍代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newChildren = n2.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldVNode = oldChildren[j]</span><br><span class="line">  <span class="keyword">let</span> newVNode = newChildren[j]</span><br><span class="line">  <span class="keyword">while</span> (oldVNode.<span class="property">key</span> === newVNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">    j++</span><br><span class="line">    oldVNode = oldChildren[j]</span><br><span class="line">    newVNode = newChildren[j]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> oldEnd = oldChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newEnd = newChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  oldVNode = oldChildren[oldEnd]</span><br><span class="line">  newVNode = newChildren[newEnd]</span><br><span class="line">  <span class="keyword">while</span> (oldVNode.<span class="property">key</span> === newVNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">    oldEnd--</span><br><span class="line">    newEnd--</span><br><span class="line">    oldVNode = oldChildren[oldEnd]</span><br><span class="line">    newVNode = newChildren[newEnd]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;</span><br><span class="line">    <span class="keyword">const</span> anchorIndex = newEnd + <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> anchor = anchorIndex &lt; newChildren.<span class="property">length</span> ? newChildren[anchorIndex].<span class="property">el</span> : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= newEnd) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, newChildren[j++], container, anchor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; newEnd &amp;&amp; j &lt;= oldEnd) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= oldEnd) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(oldChildren[j++])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = newEnd - j + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">new</span> <span class="title class_">Array</span>(count)</span><br><span class="line">    source.<span class="title function_">fill</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> oldStart = j</span><br><span class="line">    <span class="keyword">const</span> newStart = j</span><br><span class="line">    <span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> keyIndex = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = newStart; i &lt;= newEnd; i++) &#123;</span><br><span class="line">      keyIndex[newChildren[i].<span class="property">key</span>] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = oldStart; i &lt;= oldEnd; i++) &#123;</span><br><span class="line">      oldVNode = oldChildren[i]</span><br><span class="line">      <span class="keyword">if</span> (patched &lt; count) &#123;</span><br><span class="line">        <span class="keyword">const</span> k = keyIndex[oldVNode.<span class="property">key</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> k !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">          newVNode = newChildren[k]</span><br><span class="line">          <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">          patched++</span><br><span class="line">          source[k - newStart] = i</span><br><span class="line">          <span class="keyword">if</span> (k &lt; pos) &#123;</span><br><span class="line">            moved = <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pos = k</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="keyword">const</span> seq = <span class="title function_">lis</span>(source)</span><br><span class="line">      <span class="keyword">let</span> s = seq.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> i = count - <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[i] === -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> pos = i + newStart</span><br><span class="line">          <span class="keyword">const</span> newVNode = newChildren[pos]</span><br><span class="line">          <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">          <span class="keyword">const</span> anchor = nextPos &lt; newChildren.<span class="property">length</span></span><br><span class="line">            ? newChildren[nextPos].<span class="property">el</span></span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">          <span class="title function_">patch</span>(<span class="literal">null</span>, newVNode, container, anchor)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i !== seq[j]) &#123;</span><br><span class="line">          <span class="keyword">const</span> pos = i + newStart</span><br><span class="line">          <span class="keyword">const</span> newVNode = newChildren[pos]</span><br><span class="line">          <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">          <span class="keyword">const</span> anchor = nextPos &lt; newChildren.<span class="property">length</span></span><br><span class="line">            ? newChildren[nextPos].<span class="property">el</span></span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">          <span class="title function_">insert</span>(newVNode.<span class="property">el</span>, container, anchor)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          s--</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看出快速Diff的核心代码并不多，逻辑也很容易理解。相比双端Diff，快速Diff需要处理的边际条件会更少。其中最大的特点就是预处理以及source数组的妙用 </p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2023 HEllO
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @saku
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>